# ***\*Springcloud分布式锁的实现\****

 

#### ***\*Redis实现分布式锁：\****

最常见的一种方案就是使用Redis做分布式锁。

 

使用Redis做分布式锁的思路大概是这样的：在redis中设置一个值表示加了锁，然后释放锁的时候就把这个key删除。

 

具体代码是这样的：

 

// 获取锁

// NX是指如果key不存在就成功，key存在返回false，PX可以指定过期时间

SET anyLock unique_value NX PX 30000

// 释放锁：通过执行一段lua脚本

// 释放锁涉及到两条指令，这两条指令不是原子性的

// 需要用到redis的lua脚本支持特性，redis执行lua脚本是原子性的

if redis.call("get",KEYS[1]) == ARGV[1] then

​	return redis.call("del",KEYS[1])

else

​	return 0

End

 

 

这种方式有几大要点：

 

一定要用SET key value NX PX milliseconds 命令如果不用，先设置了值，再设置过期时间，这个不是原子性操作，有可能在设置过期时间之前宕机，会造成死锁(key永久存在)

value要具有唯一性，这个是为了在解锁的时候，需要验证value是和加锁的一致才删除key。

这是避免了一种情况：假设A获取了锁，过期时间30s，此时35s之后，锁已经自动释放了，A去释放锁，但是此时可能B获取了锁。A客户端就不能删除B的锁了。

 

 

 

 

 

 

除了要考虑客户端要怎么实现分布式锁之外，还需要考虑redis的部署问题。

 

redis 有3种部署方式：

 

单机模式

master-slave + sentinel选举模式

redis cluster模式

使用redis做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要redis故障了。加锁就不行了。

 

采用master-slave模式，加锁的时候只对一个节点加锁，即便通过sentinel做了高可用，但是如果master节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。

 

基于以上的考虑，其实redis的作者也考虑到这个问题，他提出了一个RedLock的算法，这个算法的意思大概是这样的：

 

假设redis的部署模式是redis cluster，总共有5个master节点，通过以下步骤获取一把锁：

 

获取当前时间戳，单位是毫秒

轮流尝试在每个master节点上创建锁，过期时间设置较短，一般就几十毫秒

尝试在大多数节点上建立一个锁，比如5个节点就要求是3个节点（n / 2 +1）

 

客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了

要是锁建立失败了，那么就依次删除这个锁

只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁

但是这样的这种算法还是颇具争议的，可能还会存在不少的问题，无法保证加锁的过程一定正确。